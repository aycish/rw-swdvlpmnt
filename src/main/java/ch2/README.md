# 입출금 내역 분석기

---

## [프로젝트 목표]

- 좋은 소프트웨어 개발의 기반이 무엇인지 배운다.
- 프로젝트를 진행하면서 바뀌는 요구사항이나 유지보수에 대응하며 기존 구조의 한계가 무엇인지 확인한다.
- **단일 책임 원칙**을 학습하며 소프트웨어의 품질을 유지하는데 필요한 **응집도**와 **결합도**의 특징을 학습한다.


---

## [2022-09-22] 첫번째 스텝

### 요구사항

- 은행 입출금 내역의 총 수입과 총 지출은 각각 얼마인가? 결과가 양수인가 음수인가?
- 특정 달엔 몇 건의 입출금 내역이 발생했는가?
- 지출이 가장 높은 상위 10건은 무엇인가?
- 돈을 가장 많이 소비하는 항목은 무엇인가?

**은행 거래 내역 예시**
```
30-01-2017,-100,Deliveroo
30-01-2017,-50,Tesco
01-02-2017,6000,Salaru
02-02-2017,2000,Royalties
02-02-2017,-4000,Rent
03-02-2017,3000,Tesco
05-02-2017,-30,Cinema
```

### 구현 과정

1. 은행 입출금 내역의 총 수입과 총 지출의 합은 얼마인가? 
   - KISS(Keep It Short and Simple) 원칙을 이용하여 응용 프로그램 코드를 한 개의 클래스로 구현 
   - 프로그램 Argument로 transaction 파일 명시 필요 (Resource에 있다고 가정)
   - CSV 파일로부터 String line들을 모두 읽어와, 각 line 별 ','를 기준으로 split
   - 해당 트랜잭션의 금액을 확인 후, 총 수입과 총 지출을 구하고 합 산출

2. 특정 달 (1월)엔 몇 건의 입출금 내역이 발생했는가?
   - 기존 구현 메서드 분리
   - DateTimeFormatter, LocalDate를 활용하여 특정 달을 추출
   - 트랜잭션 횟수 Count

### 고려하지 못한점

1. 데이터의 상태에 따른 코드 강건성을 보장하지 못함
   - 파일이 비어있는 경우
   - 데이터에 문제가 있어서 금액을 파싱하지 못하는 경우
   - 행의 데이터가 완벽하지 않은 경우

2. 유지 보수성
   - 특정 기능을 담당하는 코드를 쉽게 찾을 수 있어야함
   - 코드가 어떤 일을 수행하는지 쉽게 이해할 수 있어야함
   - 새로운 기능을 쉽게 추가하거나 기존 기능을 쉽게 제거할 수 있어야함
   - 캡슐화가 잘되어있어서 사용자에게 세부 구현 내용이 감쳐줘 있어야함. 그에 따라 쉽게 이해하고 기능을 변경할 수 있어야함
   - 예제에서는 파일 타입이 변경되는 경우, 다양한 형식의 파일을 지원해야하는 경우 등 하드코딩 되어있어 불안정하다.

**즉, 한개의 거대한 God Class를 만들었기 때문에 코드를 이해하기 어렵고, 코드 중복(DRY, Don't Repeat yourself)때문에 불안정하고 변화에 쉽게 망가진다.**

### 단일 책임 원칙 (Single Resposibility Principal) 적용해보기

**SRP**
- 한 클래스는 한 기능만 책임진다.
- 클래스가 바뀌어야 하는 이유는 오직 하나여야 한다.

**기능 분리를 해보자**

- 입력 읽기
- 읽어온 데이터를 주어진 형식에 따라 파싱
- 결과 처리
- 출력

**주의사항**

- (주관적) 메서드를 구현할때는 Principle of least surprise를 따라야한다.
- 메서드가 수행하는 일을 바로 이해할 수 있도록 자체 문서화를 제공하는 메서드명을 사용한다.
- 코드의 다른 부분이 파라미터의 상태에 의존할 수 있으므로, 파라미터의 상태를 바꾸지 않는다.

### 학습 내용

- KISS, DRY, SRP 원칙
- 응집도
  - 응집도는 서로 어떻게 관련되어 있는지를 가리킨다.
  - 보통 클래스에 적용하지만, 메서드에도 적용할 수 있다. 만약 메서드의 파라미터로 if/else 블럭이 많아진다면, 응집도를 떨어뜨리기 위해 메서드를 더 쪼개야한다.
- 결합도
  - 한 기능이 다른 클래스에 얼마나 의존하고 있는지를 가늠한다.
  - 많은 구체적인 클래스를 참조했다면, 기능 변경할 때 그만큼 유연성이 떨어진다.

**실무의 클래스 수준 응집도**

실무에서는 일반적으로 여섯가지 방법으로 그룹화한다.

**기능**
- 함께 사용되는 메서드를 그룹화하며, 기능 별로 클래스를 분류하여 구현한다.
- 다만, 한개의 메서드를 갖는 클래스를 너무 과도하게 만들려는 경향이 발생할 수 있다.

**정보**
- 같은 데이터나 도메인 객체를 처리하는 메서드를 그룹화한다.
- DAO가 이와같은 맥락이다.

**유틸리티**
- 메서드가 어디에 속해야할지 결정하기 어려울 때는 유틸리티 클래스에 추가하기도 한다.
- 하지만, 빈번하게 사용한다면 낮은 응집도로 이어지므로 자제해야한다.

**논리**
- 같은 논리를 갖는 메서드들을 (ex : CSV 파싱, XSL 파싱, JSON 파싱) 응집시킨다.
- 하지만 SRP에 위배되므로 권장하지 않는다.

**순차**
- 파일을 읽고, 파싱하고, 처리하고, 정보를 저장하는 메서드들을 한 클래스로 그룹화한다.
- 입출력이 순차적으로 흐르는 것을 순차 응집이라 한다.
- 하지만, 한 클래스를 바꿔야할 여러 이유가 존재하므로 SRP를 위배하며 데이터 처리방법에 따라 순식간에 로직이 복잡해진다.

**시간**
- 시간과 관련된 연산을 그룹화한다.
- 초기화와 뒷정리 (ex : DB connection 관리)가 보통 해당된다.
