# 입출금 내역 분석기 확장판

## 총 정리

- OCP(Open Close Principal)
  - 코드를 바꾸지 않고도 메서드나 클래스의 동작을 바꿀 수 있다.
  - 기존 코드를 바꾸지 않으므로 코드가 망가질 가능성이 줄어들며, 재사용성을 높이고, 결합도가 낮아져 유지보수성이 개선된다.
- 인터페이스
  - 많은 메서드를 포함하는 갓 인터페이스는 복잡도와 결합도를 높인다.
  - 너무 세밀한 메서드를 포함하는 인터페이스는 응집도를 낮춘다.
  - API의 가독성을 높이고 쉽게 이해할 수 있도록 메서드 이름을 서술적으로 만들어야한다.
- 예외처리
  - 연산 결과로 Void를 반환하면 동작을 테스트하기 어렵다.
  - 자바의 예외는 문서화, 형식 안정성, 관심사 분리를 촉진한다.
  - 확인된 예외는 불필요한 코드를 추가해야 하므로 되도록 사용하지 않는다.
  - 너무 자세하게 예외를 적용하면 소프트웨어 개발의 생산성이 떨어진다.
  - 노티피케이션 패턴을 이용해서 도메인 클래스로 오류를 수집할 수 있다.
  - 예외를 무시하거나 일반적인 Exception을 잡으면 근본적인 문제를 파악하기 어렵다.
- 빌드 도구
  - 응용프로그램 빌드, 테스트, 배포 등 소프트웨어 개발 생명 주기 작업을 자동화할 수 있다.
  - 요즘 자바 커뮤니티에서는 빌드 도구로 메이븐과 그레이들을 주로 사용한다.

---

## [프로젝트 목표]

- 코드 베이스의 유연성을 추가하고, 유지 보수성을 개선할 수 있도록 개방/폐쇄 원칙 (OCP)를 학습한다.
- 인터페이스를 언제 사용해야 좋은지 일반적인 가이드 라인을 학습한다.
- 높은 결합도를 피할 수 있는 기법을 학습한다.
- API에 예외를 포함하거나 포함하지 않을지를 포함하는 예외 처리 방법을 배운다.
- Gradle과 같은 검증된 빌드 도구를 활용하는 방안을 학습한다.

# [2022-09-27]

## 요구사항

- 특정 입출금 내역을 검색할 수 있는 기능. 예를 들어, 주어진 날짜 범위 또는 특정 범주의 입출금 내역 얻기
- 검색 결과의 요약 통계를 텍스트, HTML등 다양한 형식으로 만들기.

## 구현 내용
- 함수형 인터페이스를 통한 OCP 적용
- 세밀하지 않은 인터페이스를 통해 갓 인터페이스 구현을 방지하여 피해 안티 응집도 문제 해결
- 도메인 객체 사용 -> DTO로 이미 구현
- 다양한 형식으로 내보내기 위해 반환값 설정


## 학습 내용

### 개방/폐쇄 원칙
- 코드 베이스의 변경이 없어도, 확장성은 개방되야한다는 원칙
- BankTransactionFilter라는 함수형 인터페이스를 통해, OCP 적용

### 갓 인터페이스
- BankTransactionProcessor에 Filter를 적용하여 OCP를 확보하였으나, 기존 2장에서 구현한 다른 세개의 메서드가 문제가된다.
- 클래스가 API 역할을 한다고 보았을 때, 한 인터페이스에 모든 기능이 추가된 **갓 인터페이스**로 볼 수 있어 주의해야한다.
- 보통 작은 인터페이스를 권장한다.
  - 구현 클래스는 인터페이스에서 정의한 모든 연산의 구현 코드를 제공해야한다. 따라서 인터페이스를 바꾸면, 구현 코드도 갱신해야하고, 검증해야하는 범위도 넓어지게되기 때문
  - totalInMonth, top3등 인터페이스가 도메인 객체의 특정 접근자에 종속되는 문제가 생겼다. 도메인 객체의 세부 내용이 변경되면 인터페이스도 변경되야 하며 결과적으로 구현 코드도 변경해야 되기 때문

### 명시적 API vs 암묵적 API 제공 문제

- 일반적인 메서드를 쉽게 정의할 수 있는 상황에서 특정 상황에 구체적인 메서드를 정의해야하는지 고민되는 딜레마를 **명시적 API vs 암묵적 API 제공 문제**라고 한다.
- 특정 상황에 국한되어 각 상황에 맞는 새로운 메서드를 많이 만들어야하는 상황이 발생할 수 있다.
- 일반적인 메서드를 선언해 둔다면, 처음 사용하기가 어렵고, 문서화를 잘 해놓아야 한다.
- 자주 사용하는 연산이라면, 이를 명시적 API로 만드는것이 합리적이나 일반적인 메서드를 선언하도록 노력해보자.

### 도메인 객체 소개

- 숫자 반환 값 : 기능 변경에 따른 유연성이 떨어지며 검증해야하는 범위가 늘어난다.
- 컬렉션 : 컬렉션 결과 반환이라는 제약이 생긴다.
- 도메인 객체 : 자신의 도메인과 관련된 클래스의 인스턴스로, 결합도를 깰 수 있으며 새로운 요구사항이 생겨서 추가 정보를 내보내야 한다면 기존 코드를 변경할 필요 없이 새로운 클래스의 일부로 이를 구현할 수 있다.
- void 반환 형식은 인터페이스로부터 얻을 수 있는 정보가 없으며, 관련 테스트를 작성하기 어려우므로 특정 기능을 수행해야한다면 반환값을 적절히 설정하자.

### 예외처리

- 예외처리 기능으로 코드의 복잡성이 증가할 수 있으나, 발생한 오류를 검색하여 추적할 필요가 없고, 비즈니스 로직과 제어 흐름이 분리되어 유지보수하기 쉬워지며, 어떤 값이 오류를 가리키는 값인지 구분하기 쉽다.
- 예외 종류
  - 확인된 예외 : 회복해야하는 대상으로, 메서드가 던질 수 있는 확인된 예외 목록을 선언해야한다.
  - 미확인 예외 : 언제든 발생할 수 있는 종류의 예외로, 호출자도 이를 꼭 처리할 필요가 없다.
- 안티 패턴
  - 과도하게 세밀한 예외 : Validator를 만들어 모든 예외 상황에 대해 검증하고 회복하거나 요청한다. 너무 많은 설정 작업이 필요하고, 여러 예외를 선언해야하며, 사용자로 하여금 예외처리를 강제하여 생산성이 떨어진다.
  - 과도하게 덤덤한 예외 : 미확인 예외로 퉁쳐 선언하는 경우, 구체적인 회복 로직을 만들 수 없고, 오류 목록을 모아 사용자에게 제공할 수 없다.
- 노티피케이션 패턴 : 많은 미확인 예외를 사용하는 상황에 적합한 해결책을 제공하는 패턴으로, 도메인 클래스로 오류를 수집한다.
  - 한번에 여러 오류를 수집할 수 있는 검증자를 만들어 안티 패턴을 방지한다.

### 예외처리 가이드라인

- 예외를 무시하지 않음 : 예외를 처리할 수 있는 방법이 명확하지 않으면 미확인 예외를 대신 던져야한다.
- 일반적인 예외는 잡지 않음 : 가능한 구체적으로 예외를 잡으면 가독성이 높아지고 더 세밀하게 예외를 처리할 수 있다. 
- 예외 문서화 : javadoc문법으로 @throws로 미확인 예외를 포함한 예외를 문서화한다.
- 특정 구현에 종속된 예외를 주의 : OracleException등으로 예외를 던지면, 이를 사용하는 코드도 Oracle에 종속적이게된다.
- 예외 vs 제어 흐름 : 예외로 흐름을 제어하지 말아야한다. 가독성이 떨어지며 스택 트레이스 생성과 보존등이 관련된 부담이 생긴다.

### 예외 대안 기능

- null 사용은 지양하며, 대신 null 객체인 Optional<T>를 사용하자.
